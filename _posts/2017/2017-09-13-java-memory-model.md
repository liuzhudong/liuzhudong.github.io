---
layout: post
title: 深入理解 Java 内存模型
categories: [Java]
description: 深入理解 Java 内存模型
keywords: java, 内存模型, java memory model
---

深入理解 Java 内存模型。

# 内存模型
* 主内存
所有的变量都存储在主内存

* 工作内存
每条线程有自己的工作内存，线程的工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量。

不同线程之间也无法直接访问对方的工作内存中的变量，线程之间的变量值得传递需要通过主内存来完成。

线程、主内存、工作内存之间的关系图:
![java-memory-model-relation](http://blog.liuzhudong.com/images/java-memory-model-relation.jpg)

## 内存之间交互操作
对于下列操作指令都是原子的，不可再分的（double和long例外）

| 指令 | 作用区域 | 说明 |
| --------: | :--------: | :-------- |
| lock(加锁)  | 主内存   | 把一个变量标识为一条线程独占 |
| unlock(解锁)| 主内存   | 把一个处于锁定状态的变量释放出来 |
| read(读取)  | 主内存   | 把一个变量的值从主内存传输带线程的工作内存中，以便随后的load操作使用 |
| load(加载)  | 工作内存 | 把read操作从主内存中得到的变量值放入工作内存的变量副本中 |
| use(使用)   | 工作内存 | 把工作内存中的一个变量的值传递给执行引擎 |
| assign(赋值)| 工作内存 | 把一个从执行引擎接收到的值赋给工作内存的变量 |
| store(存储) | 工作内存 | 把工作内存中的一个变量的值传输到主内存中, 以便随后的write操作使用 |
| write(写入) | 主内存   | 把store操作从工作内存中的得到的变量的值放入主内存的变量中 |

## 指令操作规则
多线程下指令之间的操作顺序是可以插入其他线程的操作指令的，顺序不固定，锁机制下除外。
Java内存模型规定了在执行上述8种指令操作时必须满足如下规则:

* 不允许read和load、store和write操作单独出现，必须是成对出现
* 一个变量进行了assign操作不允许丢弃，必须同步回主内存
* 不允许一个线程没重新给变量赋值（没有发生assign操作），把数据同步回主内存
* 一个新的变量只能在主内存中定义初始化，不允许在工作内存中直接使用一个未被初始化的变量（即对于一个变量进行use、store操作之前必须先执行了assign和load操作）
* 一个变量只允许一条线程对其进行lock操作，但是lock操作可以被同一条线程重复操作多次，多次lock必须要执行相同次数的unlock操作
* 对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前，必须重新执行load或assign操作
* 一个变量没有执行lock操作不能执行unlock操作，不允许unlock其他线程的lock操作变量
* 对于一个变量执行unlock操作，必须先把此变量的值同步回主内存中

## 3个特性
* 原子性
* 可见性
* 有序性

synchronize同时包含3种特性，所以大部分并发同步控制使用synchronize可以满足。

volatile只保证了变量的可见性和有序性，所以只能作为轻量的并发同步使用。

## 参考
* 深入理解Java虚拟机


---

